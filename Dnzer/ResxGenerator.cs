using System.Reflection;
using System.Xml;

namespace Dnzer;

/// <summary>
/// 资源生成方法。
/// </summary>
public class ResxGenerator : IGenerator
{
    /// <summary>
    /// 执行方法。
    /// </summary>
    /// <param name="args">
    /// 参数：
    /// -p:项目名称;
    /// -d:资源文件所在的目录;
    /// </param>
    public void Generate(Arguments args)
    {
        var currentDirectory = args.CurrentDirectory;
        if (args.ContainsKey("d"))
        {
            var dir = args["d"];
            if (dir == null)
            {
                Cores.ErrorLine("目录不能为空。");
                return;
            }
            var path = Path.Combine(args.CurrentDirectory.FullName, dir!);
            if (Directory.Exists(path))
            {
                currentDirectory = new DirectoryInfo(path);
            }
            else
            {
                Cores.ErrorLine($"目录不存在: {path}");
                return;
            }
        }
        else if (args.ContainsKey("p"))
        {
            var projectName = args["p"];
            var projectPath = currentDirectory.GetFiles($"{projectName}.csproj", SearchOption.AllDirectories).FirstOrDefault();
            if (projectPath?.Exists == true)
            {
                currentDirectory = projectPath.Directory!;
            }
            else
            {
                Cores.ErrorLine($"项目不存在: {projectName}");
                return;
            }
        }
        else
        {
            currentDirectory = args.CurrentDirectory;
        }

        var resources = LoadResources(currentDirectory).ToList();
        if (resources.Count == 0)
        {
            Cores.ErrorLine("资源文件不存在。");
            return;
        }

        var scope = args.ContainsKey("public") ? "public" : "internal";
        foreach (var resource in resources)
        {
            if (!resource.ResxFile.Exists)
            {
                continue;
            }
            Cores.InfoLine($"载入文件: {resource.ResxFile.FullName}");
            var xmlDoc = new XmlDocument();
            xmlDoc.Load(resource.ResxFile.FullName);
            var data = xmlDoc.DocumentElement!.GetElementsByTagName("data");
            if (data.Count == 0)
            {
                Cores.ErrorLine("为定义任何资源项目。");
                continue;
            }

            var designer = resource.ResxFile.FullName.Replace("Resources.resx", "Resources.Designer.cs");
            Cores.InfoLine($"生成文件: {designer}");
            using var stream = new FileStream(designer, FileMode.Create, FileAccess.Write);
            using var writer = new StreamWriter(stream, System.Text.Encoding.UTF8);
            writer.WriteLine($@"//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:{Assembly.GetExecutingAssembly().GetName().Version}
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace {resource.Namespace}.Properties {{
    using System;
    
    /// <summary>
    ///   一个强类型的资源类，用于查找本地化的字符串等。
    /// </summary>
    // 此类是由 StronglyTypedResourceBuilder
    // 类通过类似于 ResGen 或 Visual Studio 的工具自动生成的。
    // 若要添加或移除成员，请编辑 .ResX 文件，然后重新运行 ResGen
    // (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""System.Resources.Tools.StronglyTypedResourceBuilder"", ""17.0.0.0"")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    {scope} class Resources {{
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(""Microsoft.Performance"", ""CA1811:AvoidUncalledPrivateCode"")]
        internal Resources() {{
        }}
        
        /// <summary>
        ///   返回此类使用的缓存的 ResourceManager 实例。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {{
            get {{
                if (object.ReferenceEquals(resourceMan, null)) {{
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(""{resource.Namespace}.Properties.Resources"", typeof(Resources).Assembly);
                    resourceMan = temp;
                }}
                return resourceMan;
            }}
        }}
        
        /// <summary>
        ///   重写当前线程的 CurrentUICulture 属性，对
        ///   使用此强类型资源类的所有资源查找执行重写。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {{
            get {{
                return resourceCulture;
            }}
            set {{
                resourceCulture = value;
            }}
        }}
");
            foreach (XmlElement element in data)
            {
                var item = new ResxItem(element);
                item.Write(writer, scope);
            }
            // 写入结束符
            writer.WriteLine(@"
    }
}");
        }
        Cores.InfoLine("资源文件生成完成。");
    }
    /// <summary>
    /// 返回帮助说明。
    /// </summary>
    /// <returns>返回帮助说明。</returns>
    public override string ToString()
    {
        return "[[-p|-d] path] [-public]\n"
            + "说明：重新生成资源文件的Resources.Designer.cs文件。\n"
            + "参数：\n"
            + " -public:公开资源类，默认为internal\n"
            + " -p:项目名称\n"
            + " -d:资源文件所在的目录\n"
            + " path:资源文件所在的目录或者项目名称，资源文件路径\n";
    }

    IEnumerable<ResxFileInfo> LoadResources(DirectoryInfo solutionDir)
    {
        var projects = solutionDir.GetFiles("*.csproj", SearchOption.AllDirectories);
        foreach (var project in projects)
        {
            yield return new ResxFileInfo(project);
        }
    }

    class ResxItem
    {
        public ResxItem(XmlElement element)
        {
            Name = element.GetAttribute("name")?.Trim() ?? string.Empty;
            Value = element["value"]?.InnerText.Trim() ?? string.Empty;
            Comment = element["comment"]?.InnerText.Trim();
            if (string.IsNullOrWhiteSpace(Comment))
                Comment = Value;
        }

        public string Name { get; }
        public string Value { get; }
        public string? Comment { get; set; }

        public void Write(StreamWriter writer, string scope)
        {
            writer.WriteLine($@"        
        /// <summary>
        ///   查找类似 {Comment ?? Value} 的本地化字符串。
        /// </summary>
        {scope} static string {Name} {{
            get {{
                return ResourceManager.GetString(""{Name}"", resourceCulture);
            }}
        }}");
        }
    }

    /// <summary>
    /// Resx配置。
    /// </summary>
    class ResxFileInfo
    {
        public ResxFileInfo(FileInfo info)
        {
            ResxFile = new FileInfo(Path.Combine(info.DirectoryName!, "Properties/Resources.resx"));
            var xmlDoc = new XmlDocument();
            xmlDoc.Load(info.FullName);
            var root = xmlDoc.DocumentElement!;
            var @namespce = root.SelectSingleNode("PropertyGroup/RootNamespace");
            if (@namespce != null)
            {
                Namespace = @namespce.InnerText;
            }
            else
            {
                Namespace = Path.GetFileNameWithoutExtension(info.Name);
            }
        }

        /// <summary>
        /// 命名空间。
        /// </summary>
        public string? Namespace { get; }

        /// <summary>
        /// 资源文件。
        /// </summary>
        public FileInfo ResxFile { get; }
    }
}
